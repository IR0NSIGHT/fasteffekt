
import src/benchmark

extern pure def xor(a: Int, b: Int): Int = "a ^ b"

extern pure def lshift(a: Int, b: Int): Int = "a << b"

def Mandelbrot(size: Int) = {
  def brot(size: Int): Int = {
    var sum = 0;
    var byteAcc = 0;
    var bitNum = 0;

    each(0, size){ y =>
      val ci: Double = (2.0 * toDouble(y) / toDouble(size)) - 1.0;

      each(0,size){ x =>
        var zrzr = 0.0;
        var zi = 0.0;
        var zizi = 0.0;
        val cr = (2.0 * toDouble(x) / toDouble(size)) - 1.5


        var z = 0;
        var notDone = true;
        var escape = 0;

        while (notDone && z < 50) {
          val zr = zrzr - zizi + cr;
          zi = 2.0 * zr * zi + ci;

          //preserve recalculation
          zrzr = zr * zr;
          zizi = zi*zi

          if (zrzr + zizi > 4.0) {
            notDone = false;
            escape = 1;
          }
          z = z + 1;
        }

        byteAcc = lshift( byteAcc, 1) + escape;
        bitNum = bitNum + 1;

        if (bitNum == 8) {
          sum = xor(sum,byteAcc);
          byteAcc = 0;
          bitNum = 0;
        } else if (x == size - 1) {
          byteAcc = lshift(byteAcc, (8 - bitNum));
          sum = xor(sum, byteAcc);
          byteAcc = 0;
          bitNum = 0;
        }
      }
    }

    return sum;
  }



  def benchmark() = {
    return brot(size)
  }

  def verifyResult(result: Int) = {
    if (size == 500) {
      (result == 191)
    } else if ( size == 750) {
      (result == 50);
    } else if ( size == 1) {
      (result == 128);
    } else {
      println("no known result for this problemsize:"++show(size)++" result="++show(result));
      false;
    }
  }

  return innerBenchmarkLoop(1){benchmark}{verifyResult}
}

def main() = {
  Mandelbrot(1);
  Mandelbrot(750);
  Mandelbrot(500);

  //unit tests
  if (xor(123,456) != 435) {
    panic("XOR operation is faulty!")
  }

   if (lshift(123,456) != 31488) {
    panic("XOR operation is faulty!")
  }
}
