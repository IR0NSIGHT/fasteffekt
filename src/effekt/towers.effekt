import mutable/array
import src/benchmark
import immutable/list

//each list represents one smallerDisk.
//TODO type alias, rename as "smallerDisk"
//smallerDisk.next is the smallerDisk below => kellerstack
type Disk = List[Int]


// def printPiles(piles: Array[Disk]) = {
//   println(pilesToString(piles))
// }

// def DiskToString(d: Disk): String = {
//   "Disk("++helper(d)++")"
// }

// def helper(d: Disk): String = {
//   d match {
//     case Cons(size, next) => ""++show(size)++" " ++ helper(next)
//     case Nil() => ""
//   }
// }

// def assert(myBool: Boolean, s: String) = {
//   if (not(myBool)) {
//     panic("assertion failed:"++s)
//   }
// }

// def pilesToString(piles: Array[Disk]): String = {
//   var s = "["
//   each(0, piles.size()){ i =>
//     s = s ++ "\n\t" ++ DiskToString(piles.unsafeGet(i))
//   }
//   s = s ++ "]"
//   s
// }

def Towers() = {

  var piles: Array[Disk] = emptyArray();
  var movesDone: Int = 0;

  def pushDisk(piles: Array[Disk], smallerDisk: Disk, pileIdx: Int): Disk = {
    val currentTopDisk: Disk = piles.unsafeGet(pileIdx);
    (smallerDisk, currentTopDisk) match {
      case (Cons(smallerSize,_), Cons(largerSize,_)) => 
        if (smallerSize >= largerSize) {
          panic("Cannot put a big smallerDisk on a smaller one:"++show(piles));
        }
    }

    //push current top disk one down, put smaller on top
    val replacer = smallerDisk match { //smallerDisk.next = currentTopDisk
      case Cons(smallerSize, next) => 
        Cons(smallerSize, currentTopDisk)
      case Nil() => panic("tried putting nothing on top of stack")
    }
    put(piles,pileIdx, replacer);
    return currentTopDisk 
  }

  def popDiskFrom(pileIdx: Int): Disk = {
    val currentTopDisk = piles.unsafeGet(pileIdx);
    
    currentTopDisk match {
      case Nil() => panic("Attempting to remove a smallerDisk from an empty pileIdx");
      case Cons(size, next) => 
      put(piles, pileIdx, next)
      return Cons(size, Nil())
    }
  }

  def moveTopDisk(fromPile: Int, toPile: Int) = {
    pushDisk(piles, popDiskFrom(fromPile), toPile);
    movesDone = movesDone + 1;
  }

  def buildTowerAt(pileIdx: Int, disks: Int) = {
    var i = disks;
    while (i >= 0) {
      pushDisk(piles, Cons(i,Nil()), pileIdx);
      i = i -1;
    }
  }

  def moveDisks(disks: Int, fromPile: Int, toPile: Int): Unit = {
    if (disks == 1) {
      moveTopDisk(fromPile, toPile);
    } else {
      val otherPile = (3 - fromPile) - toPile;
      moveDisks(disks - 1, fromPile, otherPile);
      moveTopDisk(fromPile, toPile);
      moveDisks(disks - 1, otherPile, toPile);
    }
  }

  def benchmark(): Int = {
    piles = emptyArray(3)
    put[Disk](piles,0,Nil())
    put[Disk](piles,1,Nil())
    put[Disk](piles,2,Nil())

    buildTowerAt(0, 13);

    movesDone = 0;
    moveDisks(13, 0, 1);
    return movesDone;
  }

  def verifyResult(result: Int): Boolean = {
    return result == 8191;
  }

  // def unitTest() = {
  //   //init pile array
  //   piles = emptyArray(3)
  //   put[Disk](piles,0,Nil())
  //   put[Disk](piles,1,Nil())
  //   put[Disk](piles,2,Nil())

  //   buildTowerAt(0, 3);
  //   buildTowerAt(1, 4);
  //   buildTowerAt(2, 5);

  //   val popped = popDiskFrom(1)
  //   assert(diskSize(popped) == 0,"popped correct disk")
  //   assert(diskSize(piles.unsafeGet(1)) == 1,"remaining disk has correct size"++pilesToString(piles))
    
  //   popDiskFrom(0)
  //   popDiskFrom(0)
  //   popDiskFrom(0)
  //   popDiskFrom(0)
  //   assert(piles.unsafeGet(0)==Nil(),"pile was popped empty")
    

  //   moveTopDisk(2,1)
  //   assert(diskSize(piles.unsafeGet(2))==1,"")
  //   assert(diskSize(piles.unsafeGet(1))==0,"")

  //   moveTopDisk(1,0)
  //   assert(diskSize(piles.unsafeGet(1))==1,"")
  //   assert(diskSize(piles.unsafeGet(0))==0,"")

  //   put[Disk](piles,0,Nil())
  //   put[Disk](piles,1,Nil())
  //   put[Disk](piles,2,Nil())
  //   buildTowerAt(0, 13);

  //   printPiles(piles)
  //   moveDisks(13,0,1);
  //   printPiles(piles)
  // }

  innerBenchmarkLoop(1){benchmark}{verifyResult}
}

def diskSize(d: Disk): Int = {
  d match {
    case Cons(s,_) => s
    case Nil() => -1
  }
}


def main() = {
  Towers()
}