import io/args
import text/string
import immutable/list


extern pure def currentTimeNanos(): Int = 
"""
declare i32 @clock_gettime(i32, ptr)

define i64 @current_time_nanos() {
  %1 = alloca { i64, i64 }
  %2 = call i32 @clock_gettime(i32 0, ptr %1)
  %3 = load i64, ptr %1
  %4 = mul nsw i64 %3, 1000000000
  %5 = getelementptr inbounds { i64, i64 }, ptr %1, i64 0, i32 1
  %6 = load i64, ptr %5
  %7 = add nsw i64 %4, %6
  ret i64 %7
}
"""

def measureMillis{ operation: () => Unit }: Int = {
    val startTime : Int = currentTimeNanos();
    operation();
    val diff = currentTimeNanos() - startTime;
    val runTime = diff/1000000;

    return runTime
}


//runs benchmark. will use minibench if --verify was given as cmd arg.
//returns measured time from benchmarks as list[Int] as JSON String.
def runFromCli{ miniBench: () => Unit }{ bench: () =>Unit }: String = {
    val isVerify = commandLineArgs() match {
      case Cons(_,Cons(arg,_)) => (arg == "--verify") 
      case _ => false
    }
    val iterations: Int = commandLineArgs() match {
      case Cons(its,_) => toInt(its) match {
        case None() => println("illegal value for iterations, default to 3"); 3
        case Some(i) => i
      }
      case _ => panic("cli runner was not given cmd arg for iterations!")
    }

    var durationLog: List[Int] = Nil()

    if (isVerify) {
      each(0,3){ i => 
        durationLog = Cons(measureMillis{miniBench},durationLog)
      }
    } else {
      each(0,iterations){ i =>
        durationLog = Cons(measureMillis{bench},durationLog)
      }
    }
    intListToJson(durationLog)
}


def intListToJson(l: List[Int]): String = {
  var out: String = "["
  val size = l.size()
  foreachIndex[Int](l){ (index, entry) =>
    out = out ++ show(entry); ();
    if (index < size-1)
      out = out ++ ","
  }
  out = out ++ "]"
  out
}

