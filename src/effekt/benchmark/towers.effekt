import mutable/array
import src/effekt/benchmark
import immutable/list
import src/effekt/cliRunner

type SingleDisk = Int
type StackOfDisks = List[SingleDisk]
type TowerSetup = List[StackOfDisks]


def getItemAt[A](l: List[A], idx: Int): Option[A] =
  l match {
    case Nil() => None()  //idx out of bounds
    case Cons(a, rest) => 
      if (idx == 0) { //list[idx] == a
        Some(a)
      } else {
        getItemAt(rest,idx - 1)
      }
  }

def setItemAt[A](l: List[A], item: A, idx: Int): List[A] =
  l match {
    case Nil() => panic("index out of bounds for setting item to list")
    case Cons(head, tail) => 
      if (idx == 0) {
        Cons(item, tail)  //replace existing head with item
      } else {
        Cons(head, setItemAt(tail, item, idx - 1))
      }
  }

def Towers() = {

  var towers: TowerSetup = Nil();
  var movesDone: Int = 0;

  def pushDisk(towers: TowerSetup, newTopDiskOnStack: SingleDisk, pileIdx: Int): TowerSetup = {
    val stack: Option[StackOfDisks] = getItemAt[StackOfDisks](towers, pileIdx);
    stack match {
      case Some(Cons(topDiskOnStack,rest)) => 
        if (newTopDiskOnStack >= topDiskOnStack) {
          panic("Cannot put a big disk onto a smaller one:"++show(towers));
        }

      //push current top disk one down, put smaller on top
      val updatedStack = Cons(newTopDiskOnStack, Cons(topDiskOnStack,rest))
      return setItemAt(towers,updatedStack, pileIdx);

      case None() =>
        panic("Index out of bounds: towers="++show(towers) ++ " i="++ show(pileIdx));
      } 
  }

  def popDiskFrom(pileIdx: Int, towers: TowerSetup): (TowerSetup, SingleDisk) = {
    val currentTopDisk = getItemAt(towers,pileIdx);
    
    currentTopDisk match {
      case None() => panic("Attempting to remove a disk from an invalid pileIdx");
      case Some(Cons(currentTopDisk, restOfStack)) => 
        val updatedTowers = setItemAt(towers, restOfStack, pileIdx)
        return (updatedTowers, currentTopDisk)
    }
  }

  def moveTopDisk(fromPile: Int, toPile: Int) = {
    val (poppedPiles, disk) = popDiskFrom(fromPile, towers);
    towers = pushDisk(poppedPiles, disk, toPile);
    movesDone = movesDone + 1;
  }

  def buildTowerAt(pileIdx: Int, disks: Int) = {
    var i = disks;
    while (i >= 0) {
      towers = pushDisk(towers, i, pileIdx);
      i = i -1;
    }
  }

  def moveDisks(disks: Int, fromPile: Int, toPile: Int): Unit = {
    if (disks == 1) {
      moveTopDisk(fromPile, toPile);
    } else {
      val otherPile = (3 - fromPile) - toPile;
      moveDisks(disks - 1, fromPile, otherPile);
      moveTopDisk(fromPile, toPile);
      moveDisks(disks - 1, otherPile, toPile);
    }
  }

  def benchmark(): Int = {
    towers = Cons(Nil(), Cons(Nil(), Cons(Nil(), Nil())))

    buildTowerAt(0, 13);

    movesDone = 0;
    moveDisks(13, 0, 1);
    return movesDone;
  }

  def verifyResult(result: Int): Boolean = {
    return result == 8191;
  }

  innerBenchmarkLoop(1){benchmark}{verifyResult}
}

def diskSize(d: StackOfDisks): Int = {
  d match {
    case Cons(s,_) => s
    case Nil() => -1
  }
}

def miniRun() = {
  Towers()
}

def normalRun() = {
  each(0,100){ i => 
    Towers()
  }
}

def main() = {
  println(runFromCli{ miniRun }{ normalRun })
}