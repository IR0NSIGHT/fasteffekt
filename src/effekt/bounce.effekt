import src/benchmark
import mutable/array
// class Ball {
//   constructor(random) {
//   this.x = random.next() % 500;
//   this.y = random.next() % 500;
//   this.xVel = (random.next() % 300) - 150;
//   this.yVel = (random.next() % 300) - 150;
//   }
record Ball(
  x: Double,
  y: Double,
  xVel: Double,
  yVel: Double
)

interface Random {
  def next(): Int
}

def randomBall(){ rand: Random }: Ball = {
  Ball(
    toDouble(mod(rand.next(),500)),
    toDouble(mod(rand.next(),500)),
    toDouble(mod(rand.next(),300)-150),
    toDouble(mod(rand.next(),300)-150)
  )
}

def abs(n: Double): Double = if (n < 0.0) 0.0 - n else n

//   bounce() {
//   const xLimit = 500;
//   const yLimit = 500;
//   let bounced = false;

//   this.x += this.xVel;
//   this.y += this.yVel;

//   if (this.x > xLimit) {
//     this.x = xLimit; this.xVel = 0 - Math.abs(this.xVel); bounced = true;
//   }

//   if (this.x < 0) {
//     this.x = 0; this.xVel = Math.abs(this.xVel); bounced = true;
//   }

//   if (this.y > yLimit) {
//     this.y = yLimit; this.yVel = 0 - Math.abs(this.yVel); bounced = true;
//   }

//   if (this.y < 0) {
//     this.y = 0; this.yVel = Math.abs(this.yVel); bounced = true;
//   }

//   return bounced;
//   }
// }
def bounce(ball: Ball): Tuple2[Ball, Boolean] = {
  val xLimit = 500.0;
  val yLimit = 500.0;
  var bounced = false;
  var x = ball.x + ball.xVel;
  var y = ball.y + ball.yVel;
  var xVel = ball.xVel;
  var yVel = ball.yVel;

  if (x > xLimit) {
    x = xLimit; 
    xVel = 0.0 - abs(xVel);
    bounced = true;
  }
  if (x < 0.0) {
    x = 0.0;
    xVel = abs(xVel)
    bounced = true;
  }
  if (y > yLimit) {
    y = yLimit;
    yVel = 0.0 - abs(yVel);
    bounced = true;
  }
  if (y < 0.0) {
    y = 0.0;
    yVel = abs(yVel);
    bounced = true;
  }
  (Ball(x,y, xVel, yVel), bounced)
}

def bitAnd(x: Int, y: Int) = mod(x,(y+1)) 



// class Random {
//   constructor() {
//   this.seed = 74755;
//   }

//   next() {
//   this.seed = ((this.seed * 1309) + 13849) & 65535;
//   return this.seed;
//   }


def withRandom[R]{ program: { Random } => R}: R = {
  var seed = 74755;   //FIXME is mutable from everywhere, use "withRandom" with block
  def rand = new Random {
    def next() = {
    seed = bitAnd((seed * 1309) + 13849, 65535);
    seed;
    }
  }
  program{rand}
}

def Bounce(iterations: Int) = {
  def verifyResult(result: Int) = 
    result == 1331

  def runBenchdef(){ rand: Random }: Int = {
     val ballCount = 100;
    var bounces = 0;
    val balls = emptyArray[Ball]()
    each(0, ballCount){ i => 
      val rBall = randomBall(){ rand }
      put(balls, i, rBall)
    }


    each(0, 50) { i => 
      each(0, ballCount) { i => 
        val ball = balls.unsafeGet(i);
        val (bouncedBall, didBounce) = bounce(ball);
        put(balls, i, bouncedBall);
        if (didBounce)
          bounces = bounces + 1;
      }
    }
    
    return bounces;
  }

  def benchmark(): Int = {
    withRandom{ { rand: Random } => runBenchdef(){ rand }}
  }  
  
  innerBenchmarkLoop(iterations){benchmark}{verifyResult}
}

def main() = {
  Bounce(1)
}




