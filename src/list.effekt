import src/benchmark
import immutable/list

def length(element: List[Int]): Int =
    element match {
        case Nil() => 0
        case Cons(value, child) => 1 + length(child) 
    }

def isShorterThan(x: List[Int], y: List[Int]): Boolean = {
    var xTail = x;
    var yTail = y;
    var run = true;
    var bigger = false;
    while (run) {   //TODO use recursion here
        (xTail,yTail) match {
            case (_, Nil()) => run = false; bigger = false;
            case (Nil(), _) => run =false; bigger = true;
            case (Cons(_,xx),Cons(_,yy)) => xTail = xx; yTail = yy;
        }
    }
    return bigger;
}

def makeList(length: Int): List[Int] = {
    if (length == 0) {
        Nil()
    } else {
        Cons(length, makeList(length - 1))
    }
}

//no idea what that function does.
def tail(x: List[Int], y: List[Int], z: List[Int]): List[Int] = {
    if (y.isShorterThan(x)) {
        (x,y,z) match {
            case (Cons(_,xx),Cons(_,yy),Cons(_,zz)) => 
                val yChild : List[Int] = yy;
                val zChild : List[Int] = zz;
                val xChild : List[Int] = xx;

                tail(
                    tail(xChild, y, z),
                    tail(yChild, z, x),
                    tail(zChild, x, y)
                )
            case _ => panic("oh no!");
        }
    } else {
        z;
    }
}

def List(_: Int) = {
    def benchmark(): Int = {
        val result = 
        tail(
            makeList(15),
            makeList(10),
            makeList(6)
        );
        length(result);
    }
    

    def verifyResult(result: Int): Boolean = {
        return result == 10;
    }

    return innerBenchmarkLoop(1){benchmark}{verifyResult};
}

def main() = {
    List(0);
}